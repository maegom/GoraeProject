<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>각관 + 평철프레임 | 고래이음 난간 시뮬레이터</title>

  <link rel="stylesheet" href="../../shared/css/app.css" />

  <style>
    body {
      margin: 0;
      display: flex;
      font-family: 'Pretendard', sans-serif;
      background: #f8f9fa;
      color: #333;
    }

    #sidebar {
      width: 320px;
      padding: 18px 18px 22px;
      background: #fff;
      height: 100vh;
      overflow-y: auto;
      box-shadow: 2px 0 15px rgba(0, 0, 0, .05);
      z-index: 100;
    }

    #canvas-container {
      flex-grow: 1;
      position: relative;
      background: #eee;
    }

    .input-group {
      margin-bottom: 16px;
    }

    label {
      display: block;
      font-size: 13px;
      color: #555;
      margin-bottom: 8px;
      font-weight: 700;
    }

    input[type="number"] {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      box-sizing: border-box;
      font-size: 14px;
    }

    input[type="number"]:focus {
      border-color: #007bff;
      outline: none;
    }

    .pageTitle {
      font-size: 16px;
      font-weight: 900;
      margin: 8px 0 4px;
    }

    .pageSub {
      font-size: 12px;
      color: #777;
      margin: 0 0 14px;
      line-height: 1.5;
    }

    .row2 {
      display: flex;
      gap: 8px;
    }

    .row2 input {
      width: 50%;
    }

    .info-box {
      font-size: 11px;
      color: #888;
      line-height: 1.6;
      background: #f1f3f5;
      padding: 10px;
      border-radius: 10px;
      margin-top: 14px;
    }

    .loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, .82);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 200;
      visibility: hidden;
      font-weight: 900;
    }

    .badge {
      display: inline-block;
      font-size: 11px;
      font-weight: 900;
      padding: 6px 10px;
      border-radius: 999px;
      background: #f1f3f5;
      color: #495057;
      margin-top: 8px;
    }

    /* ===== Sidebar Sections (Accordion) ===== */
    .acc {
      border: 1px solid #e9ecef;
      border-radius: 12px;
      background: #fff;
      overflow: hidden;
      margin: 10px 0;
    }

    .acc>summary {
      list-style: none;
      cursor: pointer;
      user-select: none;
      padding: 12px 12px;
      font-size: 13px;
      font-weight: 900;
      color: #343a40;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f8f9fa;
      border-bottom: 1px solid #eef1f4;
    }

    .acc>summary::-webkit-details-marker {
      display: none;
    }

    .acc>summary .chev {
      font-weight: 900;
      color: #868e96;
      transform: rotate(0deg);
      transition: transform .15s ease;
    }

    .acc[open]>summary .chev {
      transform: rotate(90deg);
    }

    .acc-body {
      padding: 12px;
    }

    .btn-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn-mini {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #e0e0e0;
      background: #f3f5f7;
      color: #222;
      font-weight: 900;
      cursor: pointer;
      user-select: none;
      flex: 1;
      min-width: 88px;
    }

    .btn-mini.on {
      background: #e7f1ff;
      border-color: #a8ccff;
      color: #0b57d0;
    }

    .step-box {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      background: #f1f3f5;
      margin-top: 10px;
      font-size: 12px;
      color: #495057;
      font-weight: 900;
    }

    .step-pill {
      padding: 6px 10px;
      border-radius: 999px;
      background: #fff;
      border: 1px solid #e9ecef;
      color: #0b57d0;
      font-weight: 900;
      font-size: 12px;
      min-width: 56px;
      text-align: center;
    }

    .tiny-help {
      font-size: 11px;
      color: #888;
      line-height: 1.5;
      margin-top: 10px;
    }
  </style>
</head>

<body>
  <header class="topbar" style="position:fixed; left:320px; right:0; top:0;">
    <a class="brand" href="#" id="brandLink">고래이음</a>
    <nav class="nav">
      <a href="#" id="homeLink">Home</a>
      <a class="active" href="../">Back</a>
    </nav>
  </header>

  <!-- ✅ 사이드바 (1번 open, 나머지 접힘) -->
  <aside id="sidebar">
    <div class="badge">Railing / SquareTube + Flatbar Frame</div>
    <div class="pageTitle">각관 + 평철 모듈 난간</div>
    <p class="pageSub">값 변경 시 3D 모델이 실시간 업데이트됩니다.</p>

    <!-- ✅ 1) 보기/공정 섹션(summary 텍스트 변경 + 내부 순서 변경)
     기존 <details class="acc" open> ... </details> 블록을 아래로 교체하세요. -->

    <details class="acc" open>
      <summary>
        <span>1. 보기 및 공정 시뮬</span>
        <span class="chev">›</span>
      </summary>

      <div class="acc-body">

        <!-- ✅ (1) 전체 색상: 맨 위 -->
        <div class="input-group" style="margin-top:0;">
          <label>색상 변경</label>

          <!-- 컬러 + 사람토글 한 줄 -->
          <div style="display:flex; gap:10px; align-items:center;">
            <input type="color" id="allColor" value="#666666" style="flex:1; height:42px;" />

            <button id="btnHuman" class="btn-mini on" type="button" style="flex:0; min-width:110px;">
              사람 ON
            </button>
          </div>
        </div>
        <!-- ✅ (2) 단계: 그 밑 -->
        <div class="step-box" style="margin-top:10px;">
          <span>단계</span>
          <span class="step-pill" id="buildStepLabel">0 / 4</span>
        </div>

        <div class="btn-row" style="margin-top:10px;">
          <button id="btnStepPrev" class="btn-mini" type="button">Prev</button>
          <button id="btnStepNext" class="btn-mini" type="button">Next</button>
          <button id="btnStepReset" class="btn-mini" type="button">Reset</button>
        </div>

        <!-- ✅ (3) ON/OFF 토글: 맨 아래 -->
        <div class="btn-row" style="margin-top:12px;">
          <button id="btnPosts" class="btn-mini on" type="button">받침 ON</button>
          <button id="btnBotRail" class="btn-mini on" type="button">아래레일 ON</button>
          <button id="btnSlats" class="btn-mini on" type="button">살 ON</button>
          <button id="btnTopRail" class="btn-mini on" type="button">위레일 ON</button>
        </div>

        <div class="tiny-help">
          * 단계(0~4): 0=모두OFF → 1=받침 → 2=아래레일 → 3=살 → 4=위레일
        </div>
      </div>
    </details>

    <!-- 2) 전체 설정 -->
    <details class="acc">
      <summary>
        <span>2. 전체 설정</span>
        <span class="chev">›</span>
      </summary>
      <div class="acc-body">
        <div class="input-group">
          <label>전체 길이 (mm)</label>
          <input type="number" id="totalL" value="3000">
        </div>
        <div class="input-group">
          <label>난간 높이 (mm)</label>
          <input type="number" id="height" value="1200">
        </div>
      </div>
    </details>

    <!-- 3) 레일(각관) -->
    <details class="acc">
      <summary>
        <span>3. 레일(각관)</span>
        <span class="chev">›</span>
      </summary>
      <div class="acc-body">
        <div class="input-group">
          <label>각관 외경 W/H (mm)</label>
          <div class="row2">
            <input type="number" id="tubeW" value="50" title="각관 폭 W">
            <input type="number" id="tubeH" value="30" title="각관 높이 H">
          </div>
        </div>
        <div class="input-group">
          <label>각관 두께 (mm)</label>
          <input type="number" id="tubeT" value="2.3" step="0.1">
        </div>
      </div>
    </details>

    <!-- 4) 살 모듈 (ㅁ자) -->
    <details class="acc">
      <summary>
        <span>4. 살 모듈 (ㅁ자)</span>
        <span class="chev">›</span>
      </summary>
      <div class="acc-body">
        <div class="input-group">
          <label>평철 폭 / 두께 (mm)</label>
          <div class="row2">
            <input type="number" id="barW" value="45" title="평철 폭">
            <input type="number" id="barT" value="6" title="평철 두께">
          </div>
        </div>
        <div class="input-group">
          <label>ㅁ자 모듈 가로폭 (mm) <span style="font-weight:400;">(세로부재 중심-중심)</span></label>
          <input type="number" id="moduleW" value="100">
        </div>
        <div class="input-group">
          <label>ㅁ자 모듈 간격 (mm) <span style="font-weight:400;">(모듈-모듈 사이)</span></label>
          <input type="number" id="moduleGap" value="100">
        </div>
      </div>
    </details>

    <!-- 5) 받침(기둥) -->
    <details class="acc">
      <summary>
        <span>5. 받침(기둥)</span>
        <span class="chev">›</span>
      </summary>
      <div class="acc-body">
        <div class="input-group">
          <label>받침(기둥) 간격 (mm)</label>
          <input type="number" id="postInt" value="1000">
        </div>
        <div class="input-group">
          <label>바닥 띄움(받침 높이) (mm)</label>
          <input type="number" id="ground" value="60">
        </div>
        <div class="input-group">
          <label>받침 ㅗ 헤드 길이 (mm)</label>
          <input type="number" id="postHeadLen" value="180">
        </div>
      </div>
    </details>

    <div class="info-box">
      * 프레임(ㅁ자)은 각관 내부에 반복 배치됩니다.<br>
      * 추후: 프레임 두께/방향, 레일 컷(겹침) 로직, 앙카/홀 등 세부 고도화 가능.
    </div>
  </aside>

  <main id="canvas-container" style="padding-top:56px;">
    <div id="loading" class="loading-overlay">모델 데이터를 불러오는 중...</div>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    let scene, camera, renderer, controls, railingGroup, humanModel;

    // ✅ 여기만 바꾸면 Home/Brand 이동 URL 변경
    const HOME_URL = "https://goraeeum.cafe24.com/";

    // ✅ 보기 토글(부재별)
    const VIEW = {
      showPosts: true,
      showBotRail: true,
      showSlats: true,
      showTopRail: true,
      showHuman: true,
    };

    // ✅ 공정 단계(0~4)
    const BUILD = {
      step: 4, // 기본: 전체 보이게 시작(원하면 0으로 바꾸면 됨)
    };

    // ==============================
    // 받침 설계(코드에서만 수정)
    // ==============================
    const POST_CFG = {
      stemWScaleToTube: 0.35,     // stem 가로폭 = tubeW * scale
      stemDScaleToTube: 0.35,     // stem 깊이   = tubeH * scale
      headTLinkedToBarT: true,
      baseTLinkedToBarT: true,
      baseTScale: 1.4,
      headTScale: 1.0,

      showAnchors: true,
      anchorRad: 8,
      anchorHeight: 8,
      holeOffsetX: 50,
      holeOffsetZ: 25,

      holeCount: 2,
      holeSegs: 6,

      postZ: 0,
    };

    const SLAT_CFG = {
      type: "RECT_FRAME", // "RECT_FRAME" | "VERT_PIPES" | "H_BARS"
      color: 0x999999,
      barW: null,
      barT: null,

      pipeOD: 16,
      pipeT: 1.5,
      pipeCount: 8,
      pipeInset: 8,
    };

    // ✅ 전체 컬러(레이아웃 전체 공통 색)
    const THEME = {
      all: 0x666666,
    };

    function hexToInt(hex) {
      return parseInt(hex.replace("#", ""), 16);
    }

    function applyColorToGroup(group, colorInt) {
      group.traverse((obj) => {
        if (!obj.isMesh) return;
        const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
        mats.forEach((m) => {
          if (!m) return;
          if (m.color) m.color.setHex(colorInt);
          m.needsUpdate = true;
        });
      });
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf1f3f5);

      camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 320) / window.innerHeight, 10, 50000);
      camera.position.set(2500, 1500, 3000);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth - 320, window.innerHeight);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.2));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(2000, 4000, 2000);
      scene.add(dirLight);

      scene.add(new THREE.GridHelper(10000, 50, 0xd1d1d1, 0xe1e1e1));

      railingGroup = new THREE.Group();
      scene.add(railingGroup);

      wireUI();
      loadHuman();
      renderRailing();
    }

    let _renderT = null;
    function requestRender() {
      clearTimeout(_renderT);
      _renderT = setTimeout(() => renderRailing(), 30);
    }

    function syncBtn(btn, onText, offText, isOn) {
      if (!btn) return;
      btn.classList.toggle('on', isOn);
      btn.textContent = isOn ? onText : offText;
    }

    function syncStepLabel() {
      const el = document.getElementById('buildStepLabel');
      if (!el) return;
      el.textContent = `${BUILD.step} / 4`;
    }

    // step -> VIEW 상태 반영
    function applyStepToView() {
      const s = BUILD.step;
      VIEW.showPosts = s >= 1;
      VIEW.showBotRail = s >= 2;
      VIEW.showSlats = s >= 3;
      VIEW.showTopRail = s >= 4;
    }

    // VIEW -> 버튼 반영
    function syncViewButtons() {
      syncBtn(document.getElementById('btnPosts'), '받침 ON', '받침 OFF', VIEW.showPosts);
      syncBtn(document.getElementById('btnBotRail'), '아래레일 ON', '아래레일 OFF', VIEW.showBotRail);
      syncBtn(document.getElementById('btnSlats'), '살 ON', '살 OFF', VIEW.showSlats);
      syncBtn(document.getElementById('btnTopRail'), '위레일 ON', '위레일 OFF', VIEW.showTopRail);
    }

    function syncHumanButton() {
      syncBtn(document.getElementById('btnHuman'), '사람 ON', '사람 OFF', VIEW.showHuman);
    }

    function applyHumanVisibility() {
      if (!humanModel) return; // 아직 로드 전이면 무시
      const inScene = humanModel.parent === scene;

      if (VIEW.showHuman && !inScene) scene.add(humanModel);
      if (!VIEW.showHuman && inScene) scene.remove(humanModel);
    }

    function wireUI() {
      // Home/Brand 링크
      const homeLink = document.getElementById('homeLink');
      if (homeLink) homeLink.href = HOME_URL;
      const brandLink = document.getElementById('brandLink');
      if (brandLink) brandLink.href = HOME_URL;

      // number input -> 디바운스 렌더
      document.querySelectorAll('input[type="number"]').forEach(el => {
        el.addEventListener('input', requestRender);
      });

      // color -> change
      const allColorEl = document.getElementById('allColor');
      if (allColorEl) {
        THEME.all = hexToInt(allColorEl.value || "#666666");
        allColorEl.addEventListener('change', (e) => {
          THEME.all = hexToInt(e.target.value || "#666666");
          applyColorToGroup(railingGroup, THEME.all);
        });
      }

      // ✅ 초기 단계 설정(기본 step=4)
      applyStepToView();
      syncStepLabel();
      syncViewButtons();

      syncHumanButton();
      applyHumanVisibility();

      // 토글 버튼들(수동 토글 시 step은 0으로 내려서 "공정 모드 해제")
      const btnPosts = document.getElementById('btnPosts');
      const btnBot = document.getElementById('btnBotRail');
      const btnSlats = document.getElementById('btnSlats');
      const btnTop = document.getElementById('btnTopRail');

      const btnHuman = document.getElementById('btnHuman');
      if (btnHuman) btnHuman.addEventListener('click', () => {
        VIEW.showHuman = !VIEW.showHuman;
        syncHumanButton();
        applyHumanVisibility();
      });

      if (btnPosts) btnPosts.addEventListener('click', () => {
        VIEW.showPosts = !VIEW.showPosts;
        BUILD.step = 0;
        syncStepLabel();
        syncViewButtons();
        requestRender();
      });

      if (btnBot) btnBot.addEventListener('click', () => {
        VIEW.showBotRail = !VIEW.showBotRail;
        BUILD.step = 0;
        syncStepLabel();
        syncViewButtons();
        requestRender();
      });

      if (btnSlats) btnSlats.addEventListener('click', () => {
        VIEW.showSlats = !VIEW.showSlats;
        BUILD.step = 0;
        syncStepLabel();
        syncViewButtons();
        requestRender();
      });

      if (btnTop) btnTop.addEventListener('click', () => {
        VIEW.showTopRail = !VIEW.showTopRail;
        BUILD.step = 0;
        syncStepLabel();
        syncViewButtons();
        requestRender();
      });

      // 공정 버튼(Play 제외)
      const btnPrev = document.getElementById('btnStepPrev');
      const btnNext = document.getElementById('btnStepNext');
      const btnReset = document.getElementById('btnStepReset');

      if (btnPrev) btnPrev.addEventListener('click', () => {
        BUILD.step = Math.max(0, BUILD.step - 1);
        applyStepToView();
        syncStepLabel();
        syncViewButtons();
        requestRender();
      });

      if (btnNext) btnNext.addEventListener('click', () => {
        BUILD.step = Math.min(4, BUILD.step + 1);
        applyStepToView();
        syncStepLabel();
        syncViewButtons();
        requestRender();
      });

      if (btnReset) btnReset.addEventListener('click', () => {
        BUILD.step = 0;
        applyStepToView();
        syncStepLabel();
        syncViewButtons();
        requestRender();
      });
    }

    function loadHuman() {
      const loader = new THREE.GLTFLoader();
      const loadingScreen = document.getElementById('loading');
      loadingScreen.style.visibility = 'visible';

      const rawUrl = '../../shared/model/SampleHuman.glb';

      loader.load(rawUrl, (gltf) => {
        humanModel = gltf.scene;
        humanModel.scale.set(25, 25, 25);
        humanModel.position.set(300, 0, -500);
        humanModel.rotation.y = Math.PI / 4;
        scene.add(humanModel);

        // ✅ 현재 토글 상태 반영
        applyHumanVisibility();
        syncHumanButton();


        loadingScreen.style.visibility = 'hidden';
        loadingScreen.innerText = '모델 데이터를 불러오는 중...';
      }, (xhr) => {
        if (!xhr.total) return;
        const percent = Math.round((xhr.loaded / xhr.total) * 100);
        loadingScreen.innerText = `모델 로딩 중... (${percent}%)`;
      }, (error) => {
        console.error('모델 로드 실패:', error);
        loadingScreen.innerText = '사람 모델 로드 실패';
      });
    }

    function createMesh(geom, color) {
      const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.6, roughness: 0.3 });
      return new THREE.Mesh(geom, mat);
    }

    function makeHollowPipeY(len, od, t, color) {
      const rOuter = od / 2;
      const rInner = Math.max(0.1, rOuter - t);

      const outerGeo = new THREE.CylinderGeometry(rOuter, rOuter, len, 32, 1, true);
      const outer = createMesh(outerGeo, color);

      const innerGeo = new THREE.CylinderGeometry(rInner, rInner, len + 0.5, 32, 1, true);
      const innerMat = new THREE.MeshStandardMaterial({
        color,
        metalness: 0.6,
        roughness: 0.3,
        side: THREE.BackSide
      });
      const inner = new THREE.Mesh(innerGeo, innerMat);

      const g = new THREE.Group();
      g.add(outer);
      g.add(inner);
      return g;
    }

    // ✅ 각관 레일(상/하) - 단순 Box 표현
    function makeRectTube(len, w, h, color) {
      const g = new THREE.BoxGeometry(len, h, w);
      return createMesh(g, color);
    }

    // ✅ ㅁ자 한 개
    function addRectFrame(centerX, yMid, innerW, innerH, barW, barT, z, color) {
      const hLen = Math.max(10, innerW);
      const vLen = Math.max(10, innerH);

      const vLenFixed = vLen + barT;
      const hLenFixed = Math.max(10, hLen - barT);

      const vGeom = new THREE.BoxGeometry(barT, vLenFixed, barW);

      const left = createMesh(vGeom, color);
      left.position.set(centerX - (hLen / 2), yMid, z);
      railingGroup.add(left);

      const right = createMesh(vGeom, color);
      right.position.set(centerX + (hLen / 2), yMid, z);
      railingGroup.add(right);

      const hGeom = new THREE.BoxGeometry(hLenFixed, barT, barW);

      const top = createMesh(hGeom, color);
      top.position.set(centerX, yMid + (vLen / 2), z);
      railingGroup.add(top);

      const bot = createMesh(hGeom, color);
      bot.position.set(centerX, yMid - (vLen / 2), z);
      railingGroup.add(bot);
    }

    // ✅ 섹션 내부를 센터링해서 ㅁ자 모듈 반복
    function addRectFrameModulesCentered({
      sectionX0,
      sectionLen,
      cut,
      yTop,
      yBot,
      z,
      moduleW,
      moduleGap,
      barW,
      barT,
      color
    }) {
      const innerX0 = sectionX0 + cut;
      const innerLen = Math.max(0, sectionLen - 2 * cut);
      if (innerLen < moduleW) return;

      const pitch = moduleW + moduleGap;
      const N = Math.max(1, Math.floor((innerLen + moduleGap) / pitch));
      const totalUsed = (N * moduleW) + ((N - 1) * moduleGap);

      const innerCenterX = innerX0 + innerLen / 2;
      const firstCenterX = (innerCenterX - totalUsed / 2) + (moduleW / 2);

      const vLen = Math.max(10, (yTop - yBot));
      const yMid = (yTop + yBot) / 2;

      for (let i = 0; i < N; i++) {
        const cx = firstCenterX + i * pitch;
        if (cx < innerX0 - 0.01) continue;
        if (cx > innerX0 + innerLen + 0.01) continue;

        addRectFrame(cx, yMid, moduleW, vLen, barW, barT, z, color);
      }
    }

    function addSlatsInSection({
      x0, sectionLen, yTop, yBot, z,
      tubeW, tubeT, barW, barT,
      cut = 0,
    }) {
      const type = SLAT_CFG.type;
      const color = SLAT_CFG.color ?? 0x999999;
      const useBarW = SLAT_CFG.barW ?? barW;
      const useBarT = SLAT_CFG.barT ?? barT;

      if (type === "RECT_FRAME") {
        const moduleW = Math.max(40, +document.getElementById('moduleW').value || 120);
        const moduleGap = Math.max(0, +document.getElementById('moduleGap').value || 60);

        const topY = yTop - (useBarT / 2);
        const botY = yBot + (useBarT / 2);

        addRectFrameModulesCentered({
          sectionX0: x0,
          sectionLen,
          cut,
          yTop: topY,
          yBot: botY,
          z,
          moduleW,
          moduleGap,
          barW: useBarW,
          barT: useBarT,
          color
        });
        return;
      }

      // VERT_PIPES / H_BARS (필요 시 유지)
      const innerTopY = yTop - (useBarW / 2);
      const innerBotY = yBot + (useBarW / 2);
      const innerH = Math.max(20, innerTopY - innerBotY);

      if (type === "VERT_PIPES") {
        const od = SLAT_CFG.pipeOD;
        const t = SLAT_CFG.pipeT;
        const n = Math.max(1, SLAT_CFG.pipeCount);
        const inset = SLAT_CFG.pipeInset;

        const usable = Math.max(20, sectionLen - inset * 2);
        const spacing = usable / (n + 1);

        for (let i = 1; i <= n; i++) {
          const px = x0 + inset + spacing * i;
          const yMid = (innerTopY + innerBotY) / 2;

          const pipe = makeHollowPipeY(innerH, od, t, color);
          pipe.position.set(px, yMid, z);
          railingGroup.add(pipe);
        }
        return;
      }

      if (type === "H_BARS") {
        const n = 4;
        for (let i = 0; i < n; i++) {
          const yy = innerBotY + (innerH * (i + 1)) / (n + 1);
          const bar = createMesh(
            new THREE.BoxGeometry(sectionLen * 0.92, useBarT, useBarW),
            color
          );
          bar.position.set(x0 + sectionLen / 2, yy, z);
          railingGroup.add(bar);
        }
        return;
      }
    }

    // ✅ 받침(ㅗ): 베이스 + stem + head + 앙카(시각용)
    function addPostT(posX, ground, tubeW, tubeH, barT, postHeadLen, postZ) {
      const baseT = POST_CFG.baseTLinkedToBarT ? Math.max(2, barT * POST_CFG.baseTScale) : 10;
      const headT = POST_CFG.headTLinkedToBarT ? Math.max(2, barT * POST_CFG.headTScale) : 6;

      const baseW = postHeadLen;
      const baseD = Math.max(tubeW, tubeH) * 1.2;

      const base = createMesh(new THREE.BoxGeometry(baseW, baseT, baseD), 0x333333);
      base.position.set(posX, baseT / 2, postZ);
      railingGroup.add(base);

      const stemW = Math.max(6, tubeW * POST_CFG.stemWScaleToTube);
      const stemD = Math.max(6, tubeH * POST_CFG.stemDScaleToTube);
      const stemH = ground;

      const stem = createMesh(new THREE.BoxGeometry(stemW, stemH, stemD), 0x444444);
      stem.position.set(posX, stemH / 2, postZ);
      railingGroup.add(stem);

      const head = createMesh(new THREE.BoxGeometry(postHeadLen, headT, baseD * 0.55), 0x444444);
      head.position.set(posX, ground + headT / 2, postZ);
      railingGroup.add(head);

      if (POST_CFG.showAnchors) {
        const offX = POST_CFG.holeOffsetX ?? 35;
        const offZ = POST_CFG.holeOffsetZ ?? offX;

        const holes = (POST_CFG.holeCount === 2)
          ? [[-offX, 0], [offX, 0]]
          : [[-offX, -offZ], [offX, -offZ], [-offX, offZ], [offX, offZ]];

        const anchorR = POST_CFG.anchorRad ?? 6;
        const anchorH = POST_CFG.anchorHeight ?? 120;
        const anchorGeo = new THREE.CylinderGeometry(anchorR, anchorR, anchorH, POST_CFG.holeSegs);

        holes.forEach(([hx, hz]) => {
          const a = createMesh(anchorGeo, 0x111111);
          a.position.set(posX + hx, baseT + anchorH / 2, postZ + hz);
          railingGroup.add(a);
        });
      }

      return { headLen: postHeadLen };
    }

    function renderRailing() {
      while (railingGroup.children.length > 0) railingGroup.remove(railingGroup.children[0]);

      const L = Math.max(100, +document.getElementById('totalL').value || 3000);
      const H = Math.max(200, +document.getElementById('height').value || 1200);

      const tubeW = Math.max(20, +document.getElementById('tubeW').value || 50);
      const tubeH = Math.max(20, +document.getElementById('tubeH').value || 50);
      const tubeT = Math.max(1, +document.getElementById('tubeT').value || 2.3);

      const barW = Math.max(5, +document.getElementById('barW').value || 25);
      const barT = Math.max(2, +document.getElementById('barT').value || 6);

      const postInt = Math.max(200, +document.getElementById('postInt').value || 1000);
      const ground = Math.max(0, +document.getElementById('ground').value || 60);
      const postHeadLen = Math.max(60, +document.getElementById('postHeadLen').value || 180);

      const yBotTube = ground + tubeH / 2;
      const yTopTube = H - tubeH / 2;

      const numSections = Math.max(1, Math.round(L / postInt));
      const actualInterval = L / numSections;

      // 받침 메타(지금은 유지)
      const postMeta = new Array(numSections + 1).fill(null).map(() => ({ headLen: 0 }));

      // 1) 받침
      if (VIEW.showPosts) {
        for (let i = 0; i <= numSections; i++) {
          const x = i * actualInterval;
          const meta = addPostT(x, ground, tubeW, tubeH, barT, postHeadLen, POST_CFG.postZ);
          postMeta[i] = meta;
        }
      }

      // 2) 레일/살(섹션 단위)
      for (let i = 0; i < numSections; i++) {
        const x0 = i * actualInterval;
        const center = x0 + actualInterval / 2;
        const railLen = actualInterval;

        // 위 레일
        if (VIEW.showTopRail) {
          const topTube = makeRectTube(railLen, tubeW, tubeH, THEME.all);
          topTube.position.set(center, yTopTube, POST_CFG.postZ);
          railingGroup.add(topTube);
        }

        // 아래 레일
        if (VIEW.showBotRail) {
          const botTube = makeRectTube(railLen, tubeW, tubeH, THEME.all);
          botTube.position.set(center, yBotTube, POST_CFG.postZ);
          railingGroup.add(botTube);
        }

        // 살(ㅁ자)
        if (VIEW.showSlats) {
          let slatCut = 0;
          if (VIEW.showPosts) {
            const stemW = Math.max(6, tubeW * POST_CFG.stemWScaleToTube);
            slatCut = (stemW / 2) + (barT / 2) + 2;
          }

          addSlatsInSection({
            x0,
            sectionLen: actualInterval,
            yTop: yTopTube - tubeH / 2,
            yBot: yBotTube + tubeH / 2,
            z: POST_CFG.postZ,
            tubeW, tubeT, barW, barT,
            cut: slatCut,
          });
        }
      }

      // 렌더 후 테마색 적용(재렌더 시 유지)
      applyColorToGroup(railingGroup, THEME.all);
    }

    window.addEventListener('resize', () => {
      camera.aspect = (window.innerWidth - 320) / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth - 320, window.innerHeight);

      const topbar = document.querySelector('.topbar');
      if (topbar) topbar.style.left = '320px';
    });

    init();

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>

</html>