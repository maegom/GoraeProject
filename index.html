<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <title>GoreIeum - 가변 포스트 난간 시뮬레이터 (v2.6)</title>
    <style>
        body {
            margin: 0;
            display: flex;
            font-family: 'Pretendard', sans-serif;
            background: #f8f9fa;
            color: #333;
        }

        #sidebar {
            width: 320px;
            padding: 25px;
            background: #ffffff;
            height: 100vh;
            overflow-y: auto;
            box-shadow: 2px 0 15px rgba(0, 0, 0, 0.05);
            z-index: 100;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            background: #eee;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 13px;
            color: #555;
            margin-bottom: 8px;
            font-weight: 600;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            box-sizing: border-box;
            transition: border 0.2s;
            font-size: 14px;
        }

        input[type="number"]:focus {
            border-color: #007bff;
            outline: none;
        }

        h2 {
            font-size: 20px;
            margin-bottom: 18px;
            color: #1a1a1a;
            border-bottom: 3px solid #007bff;
            padding-bottom: 10px;
            display: inline-block;
        }

        .row2 {
            display: flex;
            gap: 8px;
        }

        .row2 input {
            width: 50%;
        }

        .toggle-row {
            display: flex;
            gap: 10px;
            margin: 10px 0 18px;
        }

        .btn-toggle {
            flex: 1;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            background: #f3f5f7;
            color: #222;
            font-weight: 700;
            cursor: pointer;
            transition: transform .05s, background .2s, border-color .2s;
            user-select: none;
        }

        .btn-toggle:active {
            transform: translateY(1px);
        }

        .btn-toggle.on {
            background: #e7f1ff;
            border-color: #a8ccff;
            color: #0b57d0;
        }

        .info-box {
            font-size: 11px;
            color: #888;
            line-height: 1.6;
            background: #f1f3f5;
            padding: 10px;
            border-radius: 6px;
            margin-top: 14px;
        }

        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            visibility: hidden;
            font-weight: bold;
        }
    </style>
</head>

<body>

    <div id="sidebar">
        <h2>GoreIeum Modeler</h2>

        <!-- ✅ ON/OFF 토글 버튼 -->
        <div class="toggle-row">
            <button id="btnPosts" class="btn-toggle on" type="button">포스트 ON</button>
            <button id="btnRails" class="btn-toggle on" type="button">난간 ON</button>
        </div>

        <div class="input-group">
            <label>전체 길이 (mm)</label>
            <input type="number" id="totalL" value="3000">
        </div>

        <div class="input-group">
            <label>포스트(기둥) 간격 (mm)</label>
            <input type="number" id="postInt" value="1000">
        </div>

        <div class="input-group">
            <label>살(파이프) 간격 (mm)</label>
            <input type="number" id="picketGap" value="100">
        </div>

        <div class="input-group">
            <label>파이프(살) 외경 (mm)</label>
            <input type="number" id="pipeOD" value="20" step="0.1">
        </div>

        <div class="input-group">
            <label>난간 높이 (mm)</label>
            <input type="number" id="height" value="1200">
        </div>

        <div class="input-group">
            <label>평철 폭 / 두께 (mm)</label>
            <div class="row2">
                <input type="number" id="barW" value="50" title="평철 폭">
                <input type="number" id="barT" value="6" title="평철 두께">
            </div>
        </div>

        <div class="info-box">
            * <b>포스트 ON/OFF</b> : 포스트(살2개) + 받침/플레이트/앙카 + 포스트 상부 캡 포함<br>
            * <b>난간 ON/OFF</b> : 상/하 평철 + 구간 내 살(파이프) 포함
        </div>
    </div>

    <div id="canvas-container">
        <div id="loading" class="loading-overlay">모델 데이터를 불러오는 중...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let scene, camera, renderer, controls, railingGroup, humanModel;

        // ✅ 화면 토글 상태(사용자 버튼)
        const VIEW = {
            showPosts: true,
            showRails: true,
        };

        // ==============================
        // POST(포스트) 설계 파라미터 (코드에서만 수정)
        // ==============================
        const POST_CFG = {
            pairGapExtra: 2,

            postPipeRadScale: 1.0,
            postPipeSegs: 20,

            stemW: 10,
            stemDScale: 1.0,
            stemInsetY: 0,
            stemWLinkedToBar: true,
            stemWScale: 1.6,

            headWScale: 0.6,
            headT: 6,
            headTLinkedToBar: true,

            headDLinkedToBarW: true,
            headDScale: 1.0,
            headDOffset: 0,

            basePlateT: 10,
            basePlateZScale: 1.5,
            basePlateExtraW: 40,
            basePlateTLinkedToBar: true,
            basePlateTScale: 1.8,

            holeCount: 4,
            holeRad: null,
            holeOffset: 35,
            holeSegs: 24,
            anchorHeight: 30,
            anchorRad: 6,

            barCutUseHeadW: true,
            barCutExtra: 0,
            barMinLen: 80,

            makePostTopCap: true,
            postTopCapExtra: 0,
            postTopCapMin: 40,

            // ✅ 구간 평철이 포스트 캡과 겹치지 않도록 추가 컷
            railCapClearance: 2,     // 여유(겹치면 2~10mm로 증가)
            railMinLen: 80,          // 너무 짧아지면 방지


            postZ: 0,
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf1f3f5);

            camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 320) / window.innerHeight, 10, 50000);
            camera.position.set(2500, 1500, 3000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth - 320, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.2));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(2000, 4000, 2000);
            scene.add(dirLight);

            scene.add(new THREE.GridHelper(10000, 50, 0xd1d1d1, 0xe1e1e1));

            railingGroup = new THREE.Group();
            scene.add(railingGroup);

            wireUI();
            loadHuman();
            renderRailing();
        }

        function wireUI() {
            const btnPosts = document.getElementById('btnPosts');
            const btnRails = document.getElementById('btnRails');

            const syncBtn = (btn, onText, offText, isOn) => {
                btn.classList.toggle('on', isOn);
                btn.textContent = isOn ? onText : offText;
            };

            syncBtn(btnPosts, '포스트 ON', '포스트 OFF', VIEW.showPosts);
            syncBtn(btnRails, '난간 ON', '난간 OFF', VIEW.showRails);

            btnPosts.addEventListener('click', () => {
                VIEW.showPosts = !VIEW.showPosts;
                syncBtn(btnPosts, '포스트 ON', '포스트 OFF', VIEW.showPosts);
                renderRailing();
            });

            btnRails.addEventListener('click', () => {
                VIEW.showRails = !VIEW.showRails;
                syncBtn(btnRails, '난간 ON', '난간 OFF', VIEW.showRails);
                renderRailing();
            });

            document.querySelectorAll('input').forEach(el => el.addEventListener('input', renderRailing));
        }

        function loadHuman() {
            const loader = new THREE.GLTFLoader();
            const loadingScreen = document.getElementById('loading');
            loadingScreen.style.visibility = 'visible';

            const rawUrl = 'https://dl.dropboxusercontent.com/scl/fi/y395rlm5m9mhu67b52g15/SampleHuman.glb?rlkey=idzzqtoc993laykunl3ey7oyx';

            loader.load(rawUrl, (gltf) => {
                humanModel = gltf.scene;
                humanModel.scale.set(25, 25, 25);
                humanModel.position.set(300, 0, -500);
                humanModel.rotation.y = Math.PI / 4;
                scene.add(humanModel);
                loadingScreen.style.visibility = 'hidden';
                loadingScreen.innerText = '모델 데이터를 불러오는 중...';
            },
                (xhr) => {
                    if (!xhr.total) return;
                    const percent = Math.round((xhr.loaded / xhr.total) * 100);
                    loadingScreen.innerText = `모델 로딩 중... (${percent}%)`;
                },
                (error) => {
                    console.error('모델 로드 실패:', error);
                    loadingScreen.innerText = '사람 모델 로드 실패';
                });
        }

        function createMesh(geom, color) {
            const mat = new THREE.MeshStandardMaterial({
                color, metalness: 0.6, roughness: 0.3
            });
            return new THREE.Mesh(geom, mat);
        }

        function makePostPairFactory(pipeD, picketH, color) {
            const r = (pipeD / 2) * POST_CFG.postPipeRadScale;
            const segs = POST_CFG.postPipeSegs;
            const geom = new THREE.CylinderGeometry(r, r, picketH, segs);
            return () => createMesh(geom, color);
        }

        // return: { headW, basePlateW }
        function addBaseAndStand(posX, bW, bT, pGapSafe, pipeD, ground) {
            const basePlateW = pGapSafe + pipeD + POST_CFG.basePlateExtraW;

            const basePlateT = (POST_CFG.basePlateTLinkedToBar ?? false)
                ? Math.max(2, bT * (POST_CFG.basePlateTScale ?? 1.8))
                : POST_CFG.basePlateT;

            const basePlateD = bW * POST_CFG.basePlateZScale;

            const plate = createMesh(new THREE.BoxGeometry(basePlateW, basePlateT, basePlateD), 0x333333);
            plate.position.set(posX, basePlateT / 2, POST_CFG.postZ);
            railingGroup.add(plate);

            const stemW = (POST_CFG.stemWLinkedToBar ?? false)
                ? Math.max(2, bT * (POST_CFG.stemWScale ?? 1.6))
                : POST_CFG.stemW;

            const stemH = ground + POST_CFG.stemInsetY;
            const stemD = bW * POST_CFG.stemDScale;

            const stem = createMesh(new THREE.BoxGeometry(stemW, stemH, stemD), 0x444444);
            stem.position.set(posX, stemH / 2, POST_CFG.postZ);
            railingGroup.add(stem);

            const headW = basePlateW * POST_CFG.headWScale;
            const headT = (POST_CFG.headTLinkedToBar ?? true) ? bT : POST_CFG.headT;

            const headD = (POST_CFG.headDLinkedToBarW ?? true)
                ? Math.max(2, (bW * (POST_CFG.headDScale ?? 1.0)) + (POST_CFG.headDOffset ?? 0))
                : (basePlateD * (POST_CFG.headDScale ?? 1.0));

            const head = createMesh(new THREE.BoxGeometry(headW, headT, headD), 0x444444);
            head.position.set(posX, ground + headT / 2, POST_CFG.postZ);
            railingGroup.add(head);

            // 앙카(수직)
            const off = POST_CFG.holeOffset;
            const holes = (POST_CFG.holeCount === 2)
                ? [[-off, 0], [off, 0]]
                : [[-off, -off], [off, -off], [-off, off], [off, off]];

            const anchorR = (POST_CFG.holeRad != null) ? POST_CFG.holeRad : (POST_CFG.anchorRad ?? 6);
            const anchorH = POST_CFG.anchorHeight ?? 120;
            const anchorGeo = new THREE.CylinderGeometry(anchorR, anchorR, anchorH, POST_CFG.holeSegs);

            holes.forEach(([hx, hz]) => {
                const a = createMesh(anchorGeo, 0x111111);
                a.position.set(posX + hx, basePlateT + anchorH / 2, POST_CFG.postZ + hz);
                railingGroup.add(a);
            });

            return { headW, basePlateW };
        }

        function renderRailing() {
            while (railingGroup.children.length > 0) railingGroup.remove(railingGroup.children[0]);

            const L = Math.max(100, parseFloat(document.getElementById('totalL').value) || 3000);
            const pInt = Math.max(100, parseFloat(document.getElementById('postInt').value) || 1000);
            const pGap = Math.max(1, parseFloat(document.getElementById('picketGap').value) || 120);
            const pipeD = Math.max(6, parseFloat(document.getElementById('pipeOD').value) || 20);

            const bW = Math.max(1, parseFloat(document.getElementById('barW').value) || 50);
            const bT = Math.max(1, parseFloat(document.getElementById('barT').value) || 6);
            const H = Math.max(200, parseFloat(document.getElementById('height').value) || 1100);

            const ground = 60;

            const minGap = pipeD + POST_CFG.pairGapExtra;
            const pGapSafe = Math.max(pGap, minGap);

            const numSections = Math.max(1, Math.round(L / pInt));
            const actualInterval = L / numSections;

            const picketH = Math.max(50, H - ground - (bT * 2));
            const picketY = ground + bT + (picketH / 2);

            for (let i = 0; i <= numSections; i++) {
                const posX = i * actualInterval;

                // ===== POSTS =====
                let postInfo = { headW: 0, basePlateW: 0 };

                if (VIEW.showPosts) {
                    const makePost = makePostPairFactory(pipeD, picketH, 0x888888);

                    const p1 = makePost();
                    p1.position.set(posX - pGapSafe / 2, picketY, POST_CFG.postZ);
                    railingGroup.add(p1);

                    const p2 = makePost();
                    p2.position.set(posX + pGapSafe / 2, picketY, POST_CFG.postZ);
                    railingGroup.add(p2);

                    postInfo = addBaseAndStand(posX, bW, bT, pGapSafe, pipeD, ground);

                    // 포스트 상부 캡(포스트 ON일 때만)
                    if (POST_CFG.makePostTopCap) {
                        const capBase = (POST_CFG.barCutUseHeadW ?? true) ? postInfo.headW : postInfo.basePlateW;
                        const capLen = Math.max(POST_CFG.postTopCapMin ?? 40, (capBase || 0) + (POST_CFG.postTopCapExtra ?? 0));

                        const cap = createMesh(new THREE.BoxGeometry(capLen, bT, bW), 0x555555);
                        cap.position.set(posX, H, POST_CFG.postZ);
                        railingGroup.add(cap);
                    }
                }

                // ===== RAILS =====
                if (VIEW.showRails && i < numSections) {
                    const center = posX + actualInterval / 2;

                    // 평철 길이 컷(포스트가 꺼져있으면 컷 없이 전체 길이)
                    let barLen = actualInterval;

                    if (VIEW.showPosts) {
                        // (1) 포스트 받침(헤드/플레이트) 기준 컷
                        const cutBase = (POST_CFG.barCutUseHeadW ?? true) ? postInfo.headW : postInfo.basePlateW;
                        const cutX = (cutBase / 2) + (POST_CFG.barCutExtra ?? 0);

                        // (2) 포스트 캡(상부 평철) 기준 추가 컷  ✅ 핵심
                        const capBase = (POST_CFG.barCutUseHeadW ?? true) ? postInfo.headW : postInfo.basePlateW;
                        const capLen = Math.max(POST_CFG.postTopCapMin ?? 40, (capBase || 0) + (POST_CFG.postTopCapExtra ?? 0));
                        const capHalf = capLen / 2;

                        const extra = (POST_CFG.railCapClearance ?? 0);

                        // 최종: (받침 컷) + (캡 컷) 둘 중 더 큰 쪽을 채택하거나, 합산 중 택1
                        // ✅ 추천: 더 큰 쪽으로 컷하면 과하게 짧아지지 않고 겹침만 제거됨
                        const endCut = Math.max(cutX, capHalf + extra);

                        barLen = Math.max((POST_CFG.railMinLen ?? 80), actualInterval - 2 * endCut);
                    }

                    const topBar = createMesh(new THREE.BoxGeometry(barLen, bT, bW), 0x555555);
                    topBar.position.set(center, H, POST_CFG.postZ);
                    railingGroup.add(topBar);

                    const botBar = createMesh(new THREE.BoxGeometry(barLen, bT, bW), 0x555555);
                    botBar.position.set(center, ground + bT / 2, POST_CFG.postZ);
                    railingGroup.add(botBar);

                    // 구간 내 살
                    const netWidth = actualInterval - pGapSafe;
                    const subCount = Math.max(0, Math.floor(netWidth / pGapSafe) - 1);
                    const subSpacing = netWidth / (subCount + 1);

                    for (let j = 1; j <= subCount; j++) {
                        const subX = posX + (pGapSafe / 2) + (subSpacing * j);
                        const picket = createMesh(new THREE.CylinderGeometry(pipeD / 2, pipeD / 2, picketH, 16), 0xbbbbbb);
                        picket.position.set(subX, picketY, POST_CFG.postZ);
                        railingGroup.add(picket);
                    }
                }
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = (window.innerWidth - 320) / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - 320, window.innerHeight);
        });

        init();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>

</body>

</html>